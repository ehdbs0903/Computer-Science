## 비트마스킹(Bitmask) 알고리즘이란?
비트마스킹 알고리즘은 상태나 집합을 효율적으로 표현하고 조작하기 위해 비트 연산을 사용하는 알고리즘이다. 주로 배열 대신 비트를 사용하여 메모리를 절약하고, 빠른 연산을 통해 성능을 개선할 수 있다.

알고리즘의 기본 아이디어는 각 상태나 원소를 비트로 표현하고, 비트 연산을 통해 빠르게 조작하는 것이다.
<br></br>


#### 시간복잡도
비트마스킹 알고리즘의 시간 복잡도는 문제의 특성에 따라 달라진다. 예를 들어, 비트마스킹을 사용하여 방문 여부를 표시하고 탐색하는 경우, 비트 연산 자체는 O(1)로 매우 빠르다. 그러나 상태를 표현하는 비트마스크가 n개의 비트를 사용하는 경우, 모든 가능한 상태를 탐색하거나 확인해야 한다면, 최악의 경우 시간 복잡도는 O(2^n)이 될 수 있다. 이는 모든 비트 조합을 탐색하는 경우를 의미한다.
<br></br>
 

 

#### 비트마스킹의 기본 원리
1. 초기화:
    * 각 원소의 포함 여부를 나타낼 비트마스크를 초기화
    * 집합의 원소 수가 n개라면, 0부터 2n−12^n - 12n−1까지의 비트마스크를 생성하여 모든 부분 집합을 표현
    * 각 비트는 특정 원소의 포함 여부를 나타내며, 1이면 포함, 0이면 포함하지 않음을 의미
2. 계산:
    * 모든 비트마스크에 대해, 각 비트를 확인하며 해당 비트가 1일 때 그에 대응하는 원소를 부분 집합에 추가
    * 각 비트마스크 i에 대해, i의 j번째 비트가 1인지 검사하여 부분 집합을 구성
    * 이 과정은 2^n개의 비트마스크에 대해 반복적으로 수행된다
3. 응용:
    * 모든 부분 집합을 생성하기 때문에, 집합의 원소 조합을 필요로 하는 문제에서 효율적으로 사용
    * 집합의 모든 부분 집합을 탐색하는 문제, 조합 최적화 문제, 동적 계획법(DP)과 결합된 문제 등 다양한 문제에 적용
<br></br>


#### 예시
비트마스킹을 사용하여 그래프 탐색에서 각 노드의 방문 여부를 표현하고, 이를 활용하여 DFS를 구현

```
n = 5  # 노드의 수
visited = 0  # 모든 노드가 미방문 상태 (00000)

def visit_node(node):
    global visited
    visited |= (1 << node)  # node 방문 표시

def is_visited(node):
    return visited & (1 << node) != 0  # node 방문 여부 확인

# 노드 2 방문
visit_node(2)
print(bin(visited))  # 출력: 0b100

# 노드 2의 방문 여부 확인
print(is_visited(2))  # 출력: True

# 노드 1의 방문 여부 확인
print(is_visited(1))  # 출력: False
```
<br></br>
<br></br>

![image](https://github.com/user-attachments/assets/c62c61c9-959d-481a-afbb-d909df40f66f)
